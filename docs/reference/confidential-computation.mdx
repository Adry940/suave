---
title: Confidential Computation
description: Programmable privacy on SUAVE and how to make the most of it
keywords:
  - reference
  - suave
  - privacy
  - confidential
  - compute
---

# Keeping it confidential

The [MEVM](/reference/MEVM) has two modes of operation: regular and confidential (sometimes called off-chain). 

Regular mode is the same as the normal EVM. Confidential mode uses the [new confidential compute APIs](#apis), and the [precompiles](/reference/precompiles) available in [builder solidity](reference/builder-solidity), to ensure that transaction data provided by users remains private.

Builder solidity uses (and extends) all the tools and patterns you know and love. However, the concept of confidential computation being done off-chain by specific MEVM nodes is new and worth emphasizing. 

Users can encrypt their transaction data for specific MEVM nodes. Those nodes run the necessary computation (as defined in the public contract referenced in the transaction data), and insert the result into the `calldata` of a SUAVE transaction that is submitted to the public mempool, ensuring that only the results (and not the input) are broadcast publicly. 

> **This is the way we combine the benefits of public, verifiable mechanisms with private data**.

## Flow

You can sign and submit transactions as you ordinarily would on Ethereum and they will work as expected. 

We describe here what occurs when you want your transaction to _remain confidential_.

1. Create a `confidentialComputeRequest`:
    1. Specify a MEVM node: i.e. an address whose signature over the confidential computation result will be trusted. 
    2. Place your ordinary transaction in the new `confidential_input` field in the `eth_sendRawTransaction` RPC method and send it. 
    3. Messages with confidential inputs are not broadcast to the public mempool, but passed to the MEVM node whose address it is encrypted to.
2. The MEVM node executes the transaction in confidential mode, creating a `confidentialComputeResult`.
3. The `confidentialComputeResult` is set as the calldata in a "SUAVE transaction", which is broadcast to the public mempool.
4. We call this a "SUAVE transaction" because it is a normal EVM transaction, with an extra check to make sure that the MEVM node's signature matches the requested MEVM node in (2.i)

<details>
  <summary>1. How do we ensure that <code>confidentialComputeRequests</code> reach their intended MEVM nodes?</summary>
  <div>
    <div>
      Ensuring users can send their requests directly to the specified MEVM node is an area of active research. One way to do this is to ensure that the logic for sending encrypted messages to their intended recipient lives within SGX, so we can be sure it won't be tampered with.
    </div>
  </div>
</details>

<details>
  <summary>2. How do MEVM nodes get paid, or how do we protect against spam?</summary>
  <div>
    <div>
      We require a signature for each <code>confidentialComputeRequest</code>. These requests also include a <code>creationTx</code> with a gas price, thereby limiting spam. How to price SUAVE gas correctly without leaking too much information about the nature of the request is an active area of research.
    </div>
  </div>
</details>

<details>
  <summary>3. How do confidential transactions result in stuff happening (like blocks being built) on other blockchains?</summary>
  <div>
    <div>
      What we describe above occurs on SUAVE. It is the responsibility of applications on SUAVE to broadcast blocks that have been built, or the result of various kinds of auction, back to other blockchains (like Ethereum). At first, we assume that this will happen via already-established relays.
    </div>
  </div>
</details>

## Definitions

For clarity, let's define `confidentialComputeRequest` and `confidentialComputeResult`. 

1. `confidentialComputeRequest` is a _request_ for confidential computation to a specfic (set of) MEVM node(s). 
    - It holds an ordinary Ethereum transaction in its `confidential_inputs` field
    - It specifies the address(es) of the MEVM node for whom the data in the transaction is encrypted. 
    - These requests are _not_ propagated through the mempool or included in blocks.
2. `confidentialComputeResult` is the _result_ of the confidential computation, shared with the whole SUAVE chain. 
    - The MEVM node takes the `confidentialComputeRequest`, adds the result it computed, signs it, and broadcasts it as a SUAVE transaction to the mempool.
    - Confidential execution is _not_ verifiable during on-chain state transition. However, we check that the signature of the MEVM node on a SUAVE transaction comes from the public address for which the original request was encrypted. State transition only depends on the result of the confidential computation, so it remains fully reproducible.
    - SUAVE transactions are propagated through the mempool and inserted into blocks as expected, unifying confidential operation with regular operation. 

## Pictures

<AlignItems horizontal="center" vertical="center" sideMargin={0}>
<div>
  <img alt="Fairier Transformers" src={require('/static/img/confidentialCompute.png').default} />
</div>
</AlignItems>

---
TODO: everything below this needs to be updated. Also, update the picture after bugging dmarz more.

## Code

We can go over the above steps again, this time looking at the actual code required for each step:

1. You can create an ordinary EVM transaction like this in Go:

```go
allowedPeekers := []common.Address{newBlockBidPeeker, newBundleBidPeeker, buildEthBlockPeeker} // express which contracts should have access to your data (by their addresses)
offchainInnerTx := &types.LegacyTx{
    Nonce:    suaveAccNonce,
    To:       &newBundleBidAddress,
    Value:    nil,
    Gas:      1000000,
    GasPrice: 50,
    Data:     bundleBidAbi.Pack("newBid", targetBlock, allowedPeekers)
}
```

2. You can wrap (and sign) the above transaction into the new `OffchainTx` method as below, making sure to include the MEVM node's public key.

```go
offchainTx := types.SignTx(types.NewTx(&types.OffchainTx{
    ExecutionNode: "0x4E2B0c0e428AE1CDE26d5BcF17Ba83f447068E5B",
    Wrapped:       *types.NewTx(&offchainInnerTx),
}), suaveSigner, privKey)
```

3. Request confidential computation by submitting your transaction along with your confidential data to the MEVM node you chose via `eth_sendRawTransaction`.

```go
confidentialDataBytes := hexutil.Encode(ethBundle)
suaveClient.Call("eth_sendRawTransaction", offchainTx, confidentialDataBytes)
```

4. Once the MEVM node processes your computation request, the MEVM node will submit it as `OffchainExecutedTx` to the SUAVE mempool. For your reference, the two new types look like this:

```go
type OffchainTx struct {
    ExecutionNode common.Address
    Wrapped  Transaction
}
```

```go
type OffchainExecutedTx struct {
    ExecutionNode  common.Address
    Wrapped        Transaction
    OffchainResult []byte
    /* MEVM node's signature fields */
}
```

## APIs

### ConfidentialStoreBackend

The Confidential Store is an integral part of the SUAVE chain, designed to facilitate secure and privacy-preserving transactions and smart contract interactions. It is a key-value store where users can safely store and retrieve confidential data related to their bids. The Confidential Store restricts access (both read and write) to the allowed peekers of each bid, allowing developers to define the entire data model of their application.

The current implementation of `ConfidentialStoreBackend` is managed by the `LocalConfidentialStore` struct. It provides thread-safe access to the bids' confidential data.

```go
type ConfidentialStoreBackend interface {
    Initialize(bid Bid, key string, value []byte) (Bid, error)
    Store(bidId BidId, caller common.Address, key string, value []byte) (Bid, error)
    Retrieve(bid BidId, caller common.Address, key string) ([]byte, error)
}
```

The `LocalConfidentialStore` provides the following methods:

1. **Initialize**: This method is used to initialize a bid with a given `bid.Id`. If no `bid.Id` is provided, a new one is created. The method is trusted, meaning it is not directly accessible through precompiles.
2. **Store**: This method stores a given value under a specified key in a bid's `dataMap`. Access is restricted only to addresses listed in the bid's `AllowedPeekers`.
3. **Retrieve**: This method retrieves data associated with a given key from a bid's `dataMap`. Similar to the `Store` method, access is restricted only to addresses listed in the bid's `AllowedPeekers`.

Please note that the actual implementation of the Confidential Store will vary depending on future requirements and the privacy mechanisms used.

### MempoolBackend

The SUAVE mempool is a temporary storage pool for transactions waiting to be added to SUAVE. This mempool, `MempoolOnConfidentialStore`, operates on the Confidential Store, hence facilitating the privacy-preserving handling of bid transactions. The `MempoolOnConfidentialStore` is designed to handle SUAVE bids, namely the submission, retrieval, and grouping of bids by decryption condition such as block number and protocol. It provides a secure and efficient mechanism for managing these transactions while preserving their confidentiality.

The current implementation of `MempoolBackend` is managed by the `MempoolOnConfidentialStore` struct, which interacts directly with the `ConfidentialStoreBackend` interface.

```go
type MempoolBackend interface {
    SubmitBid(Bid) error
    FetchBidById(BidId) (Bid, error)
    FetchBidsByProtocolAndBlock(blockNumber uint64, namespace string) []Bid
}
```

The `MempoolOnConfidentialStore` provides the following methods:

1. **SubmitBid**: This method submits a bid to the mempool. The bid is stored in the Confidential Store with its ID as the key. Additionally, the bid is grouped by block number and protocol, which are also stored in the Confidential Store.
2. **FetchBidById**: This method retrieves a bid from the mempool using its ID.
3. **FetchBidsByProtocolAndBlock**: This method fetches all bids from a particular block that match a specified protocol.

The mempool operates on the underlying Confidential Store, thereby maintaining the confidentiality of the bids throughout the transaction process. As such, all data access is subject to the Confidential Store's security controls, ensuring privacy and integrity. 

Please note that while this initial implementation provides an idea of the ideal functionality, the final version will most likely incorporate additional features or modifications.

### OffchainEthBackend

// TODO

```go
type OffchainEthBackend interface {
    BuildEthBlock(ctx context.Context, args *BuildBlockArgs, txs types.Transactions) (*engine.ExecutionPayloadEnvelope, error)
    BuildEthBlockFromBundles(ctx context.Context, args *BuildBlockArgs, bundles []types.SBundle) (*engine.ExecutionPayloadEnvelope, error)
}
```