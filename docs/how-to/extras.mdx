# Commands

### Deploy Commands:

1. `deployBlockSenderContract`: Deploys the BlockSender contract to the Suave network. This contract is used to send constructed blocks for execution via the Boost Relay.

2. `deployMevShareContract`: Deploys the MevShare contract to the Suave network. This contract is used for sharing Maximum Extractable Value (MEV) profits with the MevExtractor contract.

### Send Commands:

1. `sendBundle`: Sends a bundle of transactions to specified MEVM contract.

2. `sendMevShareBundle`: Sends a MEVShare bundle to specified MEVM contract.

3. `sendMevShareMatch`: Sends a MEV share match transaction to the Suave network via the Boost Relay for matching MEV share recipients with their corresponding transactions.

4. `sendBuildShareBlock`: Sends a transaction to build a Goerli block using MEV-Share orderflow and sends to specified Goerli relay.

### Demo Helper Commands:

1. `startHintListener`: Starts a hint listener for demo purposes. This command listens for hints emmited from MEV-Share on the Suave Chain.

2. `subscribeBeaconAndBoost`: Subscribes to events from the Beacon Chain and Boost for demo purposes.

3. `startRelayListener`: Starts a relay listener for demo purposes. This command listens for block submisisons and deliveries from the Boost Relay.

### End-to-End (e2e) Test Commands:

1. `testDeployAndShare`: Performs an end-to-end test scenario that includes contract deployment and block sharing.

2. `buildGoerliBlocks`: Performs an end-to-end test scenario for building and sharing blocks on the Goerli network.









note to self: these code examples come from the README. See if I can work them into all that is in SUAVE cli.

We can go over the above steps again, this time looking at the actual code required for each step:

1. You can create an ordinary EVM transaction like this in Go:

```go
allowedPeekers := []common.Address{newBlockBidPeeker, newBundleBidPeeker, buildEthBlockPeeker} // express which contracts should have access to your data (by their addresses)
offchainInnerTx := &types.LegacyTx{
    Nonce:    suaveAccNonce,
    To:       &newBundleBidAddress,
    Value:    nil,
    Gas:      1000000,
    GasPrice: 50,
    Data:     bundleBidAbi.Pack("newBid", targetBlock, allowedPeekers)
}
```

2. You can wrap (and sign) the above transaction into the new `OffchainTx` method as below, making sure to include the SUAVE node's public key.

```go
offchainTx := types.SignTx(types.NewTx(&types.OffchainTx{
    ExecutionNode: "0x4E2B0c0e428AE1CDE26d5BcF17Ba83f447068E5B",
    Wrapped:       *types.NewTx(&offchainInnerTx),
}), suaveSigner, privKey)
```

3. Request confidential computation by submitting your transaction along with your confidential data to the SUAVE node you chose via `eth_sendRawTransaction`.

```go
confidentialDataBytes := hexutil.Encode(ethBundle)
suaveClient.Call("eth_sendRawTransaction", offchainTx, confidentialDataBytes)
```

4. Once the SUAVE node processes your computation request, the MEVM instance will submit it as `OffchainExecutedTx` to the public mempool. For your reference, the two new types look like this:

```go
type OffchainTx struct {
    ExecutionNode common.Address
    Wrapped  Transaction
}
```

```go
type OffchainExecutedTx struct {
    ExecutionNode  common.Address
    Wrapped        Transaction
    OffchainResult []byte
    /* SUAVE node's signature fields */
}
```